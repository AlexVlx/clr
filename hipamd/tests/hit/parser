#!/usr/bin/perl -w

use 5.006; use v5.10.1;
use File::Basename;
use File::Spec;

# Scan input file for HIT information
sub parse_file {
    my $file = shift;
    (my $exe = $file) =~ s/\.[^.]+$//g;
    my (@buildCMDs, @testCMDs, @testNamedCMDs, @cmakeCMDs);
    if (open (SOURCE, '<:encoding(UTF-8)', "$file")) {
        while (<SOURCE>) {
            my $line=$_;
            # Look for BUILD instructions
            if ($line =~ /^ \* BUILD:/) {
                $line =~ s/^ \* BUILD: //g;     # Remove " * BUILD: "
                $line =~ s/%s/$file/g;          # Substitute %s -> filename
                $line =~ s/%t/$exe/g;           # Substitute %t -> targetname
                $line =~ s/\R//g;               # Remove line endings
                push @buildCMDs, $line;
            }
            # Look for TEST instructions
            if ($line =~ /^ \* TEST:/) {
                $line =~ s/^ \* TEST: //g;      # Remove " * TEST: "
                $line =~ s/%s/$file/g;          # Substitute %s -> filename
                $line =~ s/%t/$exe/g;           # Subsitute %t -> targetname
                $line =~ s/\R//g;               # Remove line endings
                push @testCMDs, $line;
            }
            # Look for TEST_NAMED instructions
            if ($line =~ /^ \* TEST_NAMED:/) {
                $line =~ s/^ \* TEST_NAMED: //g;# Remove " * TEST_NAMED: "
                $line =~ s/%s/$file/g;          # Substitute %s -> filename
                $line =~ s/%t/$exe/g;           # Subsitute %t -> targetname
                $line =~ s/\R//g;               # Remove line endings
                push @testNamedCMDs, $line;
            }
            # Look for CMAKECMD instructions
            if ($line =~ /^ \* CMAKECMD:/) {
                $line =~ s/^ \* CMAKECMD: //g;  # Remove " * CMAKECMD: "
                # Substitute %S -> srcdir and %B -> builddir happens in cmake
                $line =~ s/\R//g;               # Remove line endings
                push @cmakeCMDs, $line;
            }
        }
        close(SOURCE);
    }
    return (\@buildCMDs, \@testCMDs, \@testNamedCMDs, \@cmakeCMDs);
}

# Exit if no arguments specified
if(scalar @ARGV == 0){
    print "No Arguments passed, exiting ...\n";
    exit(-1);
}

# Parse command
my @options = ();
my $retBuildCMDs = 0;
my $retTestCMDs = 0;
my $retTestNamedCMDs = 0;
my $retCmakeCMDs = 0;
foreach $arg (@ARGV) {
    if ($retBuildCMDs or $retTestCMDs or $retTestNamedCMDs or $retCmakeCMDs) {
        push (@options, $arg);
    }
    if ($arg eq '--buildCMDs') {
        $retBuildCMDs = 1;
    }
    if ($arg eq '--testCMDs') {
        $retTestCMDs = 1;
    }
    if ($arg eq '--testNamedCMDs') {
        $retTestNamedCMDs = 1;
    }
    if ($arg eq '--cmakeCMDs') {
        $retCmakeCMDs = 1;
    }
}

# Atleast one command needs to be specified
if (($retBuildCMDs eq 0) and ($retTestCMDs eq 0) and ($retTestNamedCMDs eq 0) and ($retCmakeCMDs eq 0)) {
    die "Usage: $0 <--buildCMDs|--testCMDs|--testNamedCMDs|--cmakeCMDs> FILENAMEs\n";
}

# Iterate over input files
foreach $file (@options) {
    # Convert absolute path to path relative to working directory
    my $relfile = File::Spec->abs2rel($file);
    my ($buildCMDs, $testCMDs, $testNamedCMDs, $cmakeCMDs) = parse_file("$relfile");
    if ($retBuildCMDs) {
        # print "BuildCMDs:\n";
        print "$_\n" for @$buildCMDs;
    }
    if ($retTestCMDs) {
        # print "TestCMDs:\n";
        print "$_\n" for @$testCMDs;
    }
    if ($retTestNamedCMDs) {
        # print "TestNamedCMDs:\n";
        print "$_\n" for @$testNamedCMDs;
    }
    if ($retCmakeCMDs) {
        # print "CmakeCMDs:\n";
        print "$_\n" for @$cmakeCMDs;
    }
}

# vim: ts=4:sw=4:expandtab:smartindent
